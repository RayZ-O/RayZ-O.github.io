---
layout: post
title: "Memory layout of objects in C++"
categories: [all, cpp]
date: 2015-07-24
author: Rui Zhang
---


An object of specific class has fixed in-memory layout in C++.
The memory layout of an object is implementation-dependent. Following content only discuss the typical implementation.
Commonly, there may be 3 kinds of members in a C++ class.

#### 1. Static member
Static class members are not tied to an instance, as *$9.4.2/1 from the C++ Standard (2003)* said,

> A static data member is not part of the subobjects of a class. There
> is only one copy of a static data member shared by all the objects of
> the class.

Typically, uninitialized static variables are stored in BSS segment and initialized static variable are stored in Data Segment.

#### 2. Non-static member data
Each class lays out its data members in the order of declaration. Thus there is a tricky way to break the data-hiding, namely access the private data member in the outside world.
Consider the following code fragment on [geeksforgeeks](http://www.geeksforgeeks.org/can-access-private-data-members-class-without-using-member-friend-function/):

{% highlight c++ %}
class Test {
private:
    int data;
public:
    Test() { data = 0; }
    int getData() { return data; }
};

int main() {
    Test t;
    int* ptr = (int*)&t;
    *ptr = 10;
    cout << t.getData();
    return 0;
}
{% endhighlight %}
It prints 10.
By casting the Test pointer to int pointer, we can successfully access the first private data member in the class.


#### 3. Non-static (plain) member funtion
All (plain) member functions are shared by all objects of the class. Usually they are stored in the read-only Text Segment(Code Segment).



It looks easy, right? However, virtual function and inheritance make the problem somewhat complex.

### **Virtual function**
Virtual function is member function that resolved at runtime, called according to the type of object pointed or refered, not the type of the pointer and reference. This capability is known as runtime polymorphism.

C++ uses the virtual table to implement virtual function. The virtual table(vtable) is a lookup table of virtual functions per class. Each entry of the vtable points to the most-derived function. It's generated by compiler if a class has virtual fuction or inherits virtual base class. Moreover, the compiler adds a hidden pointer(vptr) to the base class and corresponding code to set the vptr point to the virtual table of a class when a new object of that class is created. It makes each class object allocated bigger by the size of one pointer.

Note:

* g++ provides -fdump-class-hierarchy option to dump the class layout.
* clang also provides
-fdump-record-layouts: Dump record layout information
-fdump-vtable-layouts: Dump the layouts of all vtables that will be emitted in a translation unit

Let's see some examples(all memory layout tables are dumped on 64-bit Ubuntu 14.04):

#### 1. Trivial class without base classes and virtual functions

{% highlight c++ %}
class B {
public:
    int getInt() { return i; }
private:
    int i;
    double d;
};
{% endhighlight %}

Class layout:

~~~
  0 | class B
  0 |   int i
  8 |   double d
~~~
As mentioned above, class B lays out its data members in the order of declaration and B contains no vptr.

#### 2. Single inheritance without virtual functions

{% highlight c++ %}
class D : public B {
  int j;
  float f;
  int getInt() { return j; }
};
{% endhighlight %}

Class layout:

~~~
   0 | class D
   0 |   class B (base)
   0 |     int i
   8 |     double d
  16 |   int j
  20 |   float f
~~~
The data members of base class comes before derived class.

#### 3. Single inheritance with virtual functions

{% highlight c++ %}
class B {
public:
    virtual int getInt() { return i; }
private:
    int i;
    double d;
};

class D : public B {
  int j;
  float f;
  int getInt() { return j; }
};
{% endhighlight %}

Class layout:

~~~
   0 | class B
   0 |   (B vtable pointer)
   8 |   int i
  16 |   double d

   0 | class D
   0 |   class B (primary base)
   0 |     (B vtable pointer)
   8 |     int i
  16 |     double d
  24 |   int j
  28 |   float f
~~~
A vptr is added the the beginning of both the base class and derived class.

Vtable layout:

~~~
Vtable for 'D' (3 entries).
   0 | offset_to_top (0)
   1 | D RTTI
       -- (B, 0) vtable address --
       -- (D, 0) vtable address --
   2 | int D::getInt()

VTable indices for 'D' (1 entries).
   0 | int D::getInt()

Vtable for 'B' (3 entries).
   0 | offset_to_top (0)
   1 | B RTTI
       -- (B, 0) vtable address --
   2 | int B::getInt()

VTable indices for 'B' (1 entries).
   0 | int B::getInt()
~~~  
Notice that the Vtable also contains *offest_to_top* and *RTTI* fields.  
*offest_to_top* is useful when a class has multiple base classes.  
*RTTI*(Runtime Type Information) is used in dynamic_cast and typeid.  
As mentioned above, *getInt()* in Vtable for 'B' points to B::getInt() while in Vtable for 'D' points to D::getInt()

#### 4. Multiple inheritance without virtual functions

{% highlight c++ %}
class B1 {
public:
    int getInt() { return i; }
private:
    int i;
    double d;
};

class B2 {
public:
    int getDouble() { return e; }
private:
    int j;
    double e;
};

class D : public B1, public B2 {
public:
  int getInt() { return k; }
private:
  int k;
  float f;
};
{% endhighlight %}

Class layout:

~~~
   0 | class D
   0 |   class B1 (base)
   0 |     int i
   8 |     double d
  16 |   class B2 (base)
  16 |     int j
  24 |     double e
  32 |   int k
  36 |   float f
~~~
The data members of base classes sit in the order of base class declaration, B1's members come before B2's members. No vptr is generated. 

#### 5. Multiple inheritance with virtual functions

{% highlight c++ %}
class B1 {
public:
    virtual int getInt() { return i; }
private:
    int i;
    double d;
};

class B2 {
public:
    virtual int getDouble() { return e; }
private:
    int j;
    double e;
};

class D : public B1, public B2 {
public:
  int getInt() { return k; }
private:
  int k;
  float f;
};
{% endhighlight %}

Class layout:

~~~
   0 | class D
   0 |   class B1 (primary base)
   0 |     (B1 vtable pointer)
   8 |     int i
  16 |     double d
  24 |   class B2 (base)
  24 |     (B2 vtable pointer)
  32 |     int j
  40 |     double e
  48 |   int k
  52 |   float f
~~~
Class D inherits vptrs from B1 and B2, each of them contains function pointers pointing to the most-derived functions inherted from that class.

Vtable layout:

~~~
Vtable for 'D' (6 entries).
   0 | offset_to_top (0)
   1 | D RTTI
       -- (B1, 0) vtable address --
       -- (D, 0) vtable address --
   2 | int D::getInt()
   3 | offset_to_top (-24)
   4 | D RTTI
       -- (B2, 24) vtable address --
   5 | int B2::getDouble()

VTable indices for 'D' (1 entries).
   0 | int D::getInt()
~~~
The vtables of B1 and D coincide. The vtable of B2 comes after the vtable of B1 and D.

### Virtual Base Class
Although virtual base class brings lots of convenience to the programmer, it makes the memory layout of an object completely different and hard to understand. 

In my next post I'll discuss more about the virtual base class, happy coding geeks!
